<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Elliptical Slice Sampler with Enhanced Contour Visualization</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 0;
            padding: 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
        }
        
        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: white;
            border-radius: 20px;
            padding: 30px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
        }
        
        h1 {
            color: #333;
            text-align: center;
            margin-bottom: 10px;
        }
        
        .description {
            text-align: center;
            color: #666;
            margin-bottom: 30px;
            font-size: 14px;
            line-height: 1.6;
        }
        
        .main-content {
            display: flex;
            gap: 30px;
            margin-bottom: 30px;
        }
        
        .visualization-wrapper {
            display: flex;
            gap: 20px;
            flex: 1;
        }
        
        .canvas-container {
            position: relative;
        }
        
        .canvas-label {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(255, 255, 255, 0.95);
            padding: 5px 10px;
            border-radius: 5px;
            font-size: 12px;
            font-weight: bold;
            color: #555;
            backdrop-filter: blur(10px);
        }
        
        canvas {
            border: 1px solid #ddd;
            border-radius: 10px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
            display: block;
            background: white;
        }
        
        .side-controls {
            width: 280px;
            flex-shrink: 0;
        }
        
        .bottom-controls {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
            gap: 20px;
        }
        
        .control-group {
            background: #f7f7f7;
            padding: 15px;
            border-radius: 10px;
            margin-bottom: 15px;
        }
        
        .control-group h3 {
            margin-top: 0;
            color: #555;
            font-size: 16px;
            margin-bottom: 15px;
            border-bottom: 2px solid #ddd;
            padding-bottom: 5px;
        }
        
        .control-item {
            margin-bottom: 15px;
        }
        
        label {
            display: block;
            margin-bottom: 5px;
            color: #666;
            font-size: 14px;
            font-weight: 500;
        }
        
        input[type="range"] {
            width: 100%;
            margin-bottom: 5px;
        }
        
        .range-value {
            text-align: right;
            color: #764ba2;
            font-weight: bold;
            font-size: 12px;
        }
        
        button {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 600;
            transition: transform 0.2s, box-shadow 0.2s;
            width: 100%;
            margin-bottom: 10px;
        }
        
        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(118, 75, 162, 0.4);
        }
        
        button:active {
            transform: translateY(0);
        }
        
        .button-group {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
        }
        
        .button-group button {
            margin-bottom: 0;
        }
        
        button#clearBtn {
            margin-top: 20px;
        }
        
        .info-box {
            background: #f0f7ff;
            border-left: 4px solid #667eea;
            padding: 12px;
            border-radius: 5px;
            margin-top: 15px;
            font-size: 13px;
            color: #555;
        }
        
        .legend {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            margin-top: 15px;
            font-size: 12px;
        }
        
        .legend-item {
            display: flex;
            align-items: center;
            gap: 5px;
        }
        
        .legend-color {
            width: 20px;
            height: 20px;
            border-radius: 4px;
            border: 1px solid #ddd;
        }
        
        .stats {
            background: #fafafa;
            padding: 10px;
            border-radius: 5px;
            margin-top: 15px;
            font-size: 13px;
            font-family: 'Courier New', monospace;
        }
        
        .checkbox-item {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 10px;
        }
        
        input[type="checkbox"] {
            width: 18px;
            height: 18px;
            cursor: pointer;
        }
        
        .height-scale {
            display: flex;
            align-items: center;
            margin-top: 10px;
            font-size: 11px;
            color: #666;
        }
        
        .height-gradient {
            width: 100%;
            height: 20px;
            border-radius: 3px;
            margin: 0 10px;
            background: linear-gradient(to right, 
                rgb(50, 50, 200) 0%, 
                rgb(50, 150, 200) 25%, 
                rgb(50, 200, 150) 50%, 
                rgb(200, 200, 50) 75%, 
                rgb(200, 50, 50) 100%);
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>üéØ Elliptical Slice Sampler - Contour Crossing Visualization</h1>
        <div class="description">
            See how the elliptical slice sampler creates paths that cross through probability contours.
            The 3D view shows height-coded probability levels, while the 2D view emphasizes contour crossings.
        </div>
        
        <div class="main-content">
            <div class="visualization-wrapper">
                <div class="canvas-container">
                    <canvas id="canvas3d" width="450" height="450"></canvas>
                    <div class="canvas-label">3D Probability Landscape</div>
                </div>
                <div class="canvas-container">
                    <canvas id="canvas2d" width="450" height="450"></canvas>
                    <div class="canvas-label">2D Contour View</div>
                </div>
            </div>
            
            <div class="side-controls">
                <div class="control-group">
                    <h3>üéÆ Simulation Controls</h3>
                    <button id="stepBtn">Step Forward</button>
                    <div class="button-group">
                        <button id="runBtn">Run</button>
                        <button id="resetBtn">Reset</button>
                    </div>
                    <button id="clearBtn">Clear Samples</button>
                </div>
                
                <div class="control-group">
                    <h3>üëÅÔ∏è Display Options</h3>
                    <div class="checkbox-item">
                        <input type="checkbox" id="showMesh" checked>
                        <label for="showMesh" style="margin-bottom: 0;">Show 3D Surface</label>
                    </div>
                    <div class="checkbox-item">
                        <input type="checkbox" id="showContours" checked>
                        <label for="showContours" style="margin-bottom: 0;">Show Contour Lines</label>
                    </div>
                    <div class="checkbox-item">
                        <input type="checkbox" id="showCrossings" checked>
                        <label for="showCrossings" style="margin-bottom: 0;">Highlight Crossings</label>
                    </div>
                    <div class="checkbox-item">
                        <input type="checkbox" id="rotate3D" checked>
                        <label for="rotate3D" style="margin-bottom: 0;">Auto-rotate 3D View</label>
                    </div>
                </div>
                
                <div class="control-group">
                    <h3>üìà Statistics</h3>
                    <div class="stats" id="stats">
                        Samples: 0<br>
                        Accept Rate: 0%<br>
                        Current Œ∏: 0.00<br>
                        Current P: 0.000<br>
                        Crossings: 0
                    </div>
                </div>
            </div>
        </div>
        
        <div class="bottom-controls">
            <div class="control-group">
                <h3>‚öôÔ∏è Algorithm Parameters</h3>
                
                <div class="control-item">
                    <label for="likelihood">Likelihood Threshold:</label>
                    <input type="range" id="likelihood" min="-5" max="0" step="0.1" value="-2">
                    <div class="range-value" id="likelihoodValue">-2.0</div>
                </div>
                
                <div class="control-item">
                    <label for="speed">Animation Speed:</label>
                    <input type="range" id="speed" min="1" max="100" step="1" value="30">
                    <div class="range-value" id="speedValue">30</div>
                </div>
            </div>
            
            <div class="control-group">
                <h3>üìä Gaussian Parameters</h3>
                
                <div class="control-item">
                    <label for="correlation">Correlation (œÅ):</label>
                    <input type="range" id="correlation" min="-0.9" max="0.9" step="0.1" value="0.6">
                    <div class="range-value" id="correlationValue">0.6</div>
                </div>
                
                <div class="control-item">
                    <label for="sigmaX">Sigma X:</label>
                    <input type="range" id="sigmaX" min="0.5" max="2" step="0.1" value="1.2">
                    <div class="range-value" id="sigmaXValue">1.2</div>
                </div>
                
                <div class="control-item">
                    <label for="sigmaY">Sigma Y:</label>
                    <input type="range" id="sigmaY" min="0.5" max="2" step="0.1" value="0.8">
                    <div class="range-value" id="sigmaYValue">0.8</div>
                </div>
            </div>
            
            <div class="control-group">
                <h3>üé® Visual Legend</h3>
                <div class="legend">
                    <div class="legend-item">
                        <div class="legend-color" style="background: #ff6b6b;"></div>
                        <span>Current Point</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background: #4ecdc4;"></div>
                        <span>Auxiliary ŒΩ</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background: #ffd93d;"></div>
                        <span>Elliptical Path</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background: #95e77e;"></div>
                        <span>Valid Slice</span>
                    </div>
                </div>
                <div class="height-scale">
                    <span>Low</span>
                    <div class="height-gradient"></div>
                    <span>High</span>
                </div>
                <div style="text-align: center; font-size: 11px; color: #888; margin-top: 5px;">
                    Probability Density
                </div>
            </div>
        </div>
    </div>

    <script>
        // Shared color mapping function for consistency
        function getHeightColor(value) {
            // Normalize value to 0-1
            const normalized = Math.min(1, Math.max(0, value * 2.5));
            
            // Create gradient from blue -> cyan -> green -> yellow -> red
            let r, g, b;
            if (normalized < 0.25) {
                const t = normalized * 4;
                r = 50;
                g = 50 + t * 100;
                b = 200 - t * 150;
            } else if (normalized < 0.5) {
                const t = (normalized - 0.25) * 4;
                r = 50;
                g = 150 + t * 50;
                b = 200 - t * 50;
            } else if (normalized < 0.75) {
                const t = (normalized - 0.5) * 4;
                r = 50 + t * 150;
                g = 200;
                b = 150 - t * 100;
            } else {
                const t = (normalized - 0.75) * 4;
                r = 200;
                g = 200 - t * 150;
                b = 50;
            }
            
            return `rgb(${Math.floor(r)}, ${Math.floor(g)}, ${Math.floor(b)})`;
        }
        
        class GaussianVisualizer3D {
            constructor(canvas) {
                this.canvas = canvas;
                this.ctx = canvas.getContext('2d');
                this.width = canvas.width;
                this.height = canvas.height;
                
                // 3D parameters
                this.rotationX = -0.6;
                this.rotationZ = 0.3;
                this.autoRotate = true;
                this.scale3D = 40;
                
                // Display options
                this.showMesh = true;
                this.showContours = true;
                this.showCrossings = true;
            }
            
            project3D(x, y, z) {
                const cosX = Math.cos(this.rotationX);
                const sinX = Math.sin(this.rotationX);
                const cosZ = Math.cos(this.rotationZ);
                const sinZ = Math.sin(this.rotationZ);
                
                // Rotate around Z axis
                const x1 = x * cosZ - y * sinZ;
                const y1 = x * sinZ + y * cosZ;
                const z1 = z;
                
                // Rotate around X axis
                const x2 = x1;
                const y2 = y1 * cosX - z1 * sinX;
                const z2 = y1 * sinX + z1 * cosX;
                
                // Project to 2D with perspective
                const perspective = 1000 / (1000 + z2 * 10);
                const screenX = this.width / 2 + x2 * this.scale3D * perspective;
                const screenY = this.height / 2 - y2 * this.scale3D * perspective + 50;
                
                return [screenX, screenY, z2];
            }
            
            gaussianPDF(x, y, covInv) {
                const mahalanobis = x * x * covInv[0][0] + 
                                  2 * x * y * covInv[0][1] + 
                                  y * y * covInv[1][1];
                return Math.exp(-0.5 * mahalanobis) / (2 * Math.PI);
            }
            
            draw(sampler) {
                // Clear canvas
                this.ctx.fillStyle = '#f0f0f0';
                this.ctx.fillRect(0, 0, this.width, this.height);
                
                if (this.autoRotate) {
                    this.rotationZ += 0.003;
                }
                
                const gridSize = 25;
                const range = 3;
                const step = 2 * range / gridSize;
                
                // Create mesh points with colors
                const points = [];
                let maxZ = 0;
                for (let i = 0; i <= gridSize; i++) {
                    points[i] = [];
                    for (let j = 0; j <= gridSize; j++) {
                        const x = -range + i * step;
                        const y = -range + j * step;
                        const z = this.gaussianPDF(x, y, sampler.covInv) * 5;
                        maxZ = Math.max(maxZ, z);
                        points[i][j] = { x, y, z };
                    }
                }
                
                // Draw filled surface patches
                if (this.showMesh) {
                    // Sort patches by depth for proper rendering
                    const patches = [];
                    for (let i = 0; i < gridSize; i++) {
                        for (let j = 0; j < gridSize; j++) {
                            const centerZ = (points[i][j].z + points[i+1][j].z + 
                                           points[i][j+1].z + points[i+1][j+1].z) / 4;
                            const [, , screenZ] = this.project3D(
                                (points[i][j].x + points[i+1][j+1].x) / 2,
                                (points[i][j].y + points[i+1][j+1].y) / 2,
                                centerZ
                            );
                            patches.push({
                                i, j, screenZ, centerZ
                            });
                        }
                    }
                    patches.sort((a, b) => b.screenZ - a.screenZ);
                    
                    // Draw patches
                    for (const patch of patches) {
                        const i = patch.i;
                        const j = patch.j;
                        
                        this.ctx.beginPath();
                        const color = getHeightColor(patch.centerZ);
                        this.ctx.fillStyle = color;
                        this.ctx.strokeStyle = color;
                        this.ctx.lineWidth = 0.5;
                        
                        const corners = [
                            points[i][j],
                            points[i+1][j],
                            points[i+1][j+1],
                            points[i][j+1]
                        ];
                        
                        for (let k = 0; k < corners.length; k++) {
                            const [sx, sy] = this.project3D(corners[k].x, corners[k].y, corners[k].z);
                            if (k === 0) {
                                this.ctx.moveTo(sx, sy);
                            } else {
                                this.ctx.lineTo(sx, sy);
                            }
                        }
                        this.ctx.closePath();
                        this.ctx.globalAlpha = 0.8;
                        this.ctx.fill();
                        this.ctx.globalAlpha = 0.3;
                        this.ctx.stroke();
                        this.ctx.globalAlpha = 1;
                    }
                }
                
                // Draw contour lines at specific heights
                if (this.showContours) {
                    const contourLevels = [0.02, 0.05, 0.1, 0.15, 0.18];
                    for (const level of contourLevels) {
                        this.ctx.strokeStyle = getHeightColor(level * 5);
                        this.ctx.lineWidth = 2;
                        this.ctx.globalAlpha = 0.7;
                        
                        // Draw contour at this height
                        this.ctx.beginPath();
                        for (let angle = 0; angle <= 2 * Math.PI; angle += 0.05) {
                            const r = Math.sqrt(-2 * Math.log(level * 2 * Math.PI));
                            const x = r * Math.cos(angle) * sampler.sigmaX;
                            const y = r * Math.sin(angle) * sampler.sigmaY;
                            
                            // Apply correlation
                            const tx = x;
                            const ty = sampler.correlation * x + Math.sqrt(Math.max(0, 1 - sampler.correlation * sampler.correlation)) * y;
                            
                            const [sx, sy] = this.project3D(tx, ty, level * 5);
                            if (angle === 0) {
                                this.ctx.moveTo(sx, sy);
                            } else {
                                this.ctx.lineTo(sx, sy);
                            }
                        }
                        this.ctx.closePath();
                        this.ctx.stroke();
                        this.ctx.globalAlpha = 1;
                    }
                }
                
                // Draw ellipse path in 3D with crossing indicators
                if (sampler.ellipsePath.length > 0 && sampler.auxiliaryPoint) {
                    // Draw the full ellipse
                    this.ctx.strokeStyle = '#ffd93d';
                    this.ctx.lineWidth = 3;
                    this.ctx.globalAlpha = 0.8;
                    this.ctx.setLineDash([5, 5]);
                    this.ctx.beginPath();
                    
                    let prevHeight = 0;
                    for (let i = 0; i < sampler.ellipsePath.length; i++) {
                        const point = sampler.ellipsePath[i];
                        const pz = this.gaussianPDF(point[0], point[1], sampler.covInv) * 5;
                        const [px, py] = this.project3D(point[0], point[1], pz);
                        
                        if (i === 0) {
                            this.ctx.moveTo(px, py);
                        } else {
                            this.ctx.lineTo(px, py);
                        }
                        
                        // Mark crossing points
                        if (this.showCrossings && i > 0) {
                            const heightChange = Math.abs(pz - prevHeight);
                            if (heightChange > 0.02) {
                                this.ctx.save();
                                this.ctx.setLineDash([]);
                                this.ctx.fillStyle = getHeightColor(pz);
                                this.ctx.strokeStyle = '#fff';
                                this.ctx.lineWidth = 2;
                                this.ctx.beginPath();
                                this.ctx.arc(px, py, 4, 0, 2 * Math.PI);
                                this.ctx.fill();
                                this.ctx.stroke();
                                this.ctx.restore();
                            }
                        }
                        prevHeight = pz;
                    }
                    this.ctx.stroke();
                    this.ctx.setLineDash([]);
                    this.ctx.globalAlpha = 1;
                    
                    // Highlight valid slice
                    if (sampler.sliceMax - sampler.sliceMin < 2 * Math.PI) {
                        this.ctx.strokeStyle = '#95e77e';
                        this.ctx.lineWidth = 5;
                        this.ctx.globalAlpha = 0.9;
                        this.ctx.beginPath();
                        for (let t = sampler.sliceMin; t <= sampler.sliceMax; t += 0.05) {
                            const cos_t = Math.cos(t);
                            const sin_t = Math.sin(t);
                            const point = [
                                sampler.currentPoint[0] * cos_t + sampler.auxiliaryPoint[0] * sin_t,
                                sampler.currentPoint[1] * cos_t + sampler.auxiliaryPoint[1] * sin_t
                            ];
                            const pz = this.gaussianPDF(point[0], point[1], sampler.covInv) * 5;
                            const [px, py] = this.project3D(point[0], point[1], pz);
                            if (t === sampler.sliceMin) {
                                this.ctx.moveTo(px, py);
                            } else {
                                this.ctx.lineTo(px, py);
                            }
                        }
                        this.ctx.stroke();
                        this.ctx.globalAlpha = 1;
                    }
                }
                
                // Draw samples on the surface
                for (let i = 0; i < sampler.samples.length; i++) {
                    const sample = sampler.samples[i];
                    const z = this.gaussianPDF(sample[0], sample[1], sampler.covInv) * 5;
                    const [sx, sy, sz] = this.project3D(sample[0], sample[1], z);
                    
                    const alpha = 0.3 + (i / sampler.samples.length) * 0.5;
                    this.ctx.fillStyle = `rgba(255, 255, 255, ${alpha})`;
                    this.ctx.strokeStyle = getHeightColor(z);
                    this.ctx.lineWidth = 1;
                    this.ctx.beginPath();
                    this.ctx.arc(sx, sy, 3, 0, 2 * Math.PI);
                    this.ctx.fill();
                    this.ctx.stroke();
                }
                
                // Draw current point with vertical line
                const z = this.gaussianPDF(sampler.currentPoint[0], sampler.currentPoint[1], sampler.covInv) * 5;
                const [sx, sy] = this.project3D(sampler.currentPoint[0], sampler.currentPoint[1], z);
                const [sx0, sy0] = this.project3D(sampler.currentPoint[0], sampler.currentPoint[1], 0);
                
                // Vertical line
                this.ctx.strokeStyle = 'rgba(255, 107, 107, 0.3)';
                this.ctx.lineWidth = 1;
                this.ctx.setLineDash([2, 2]);
                this.ctx.beginPath();
                this.ctx.moveTo(sx0, sy0);
                this.ctx.lineTo(sx, sy);
                this.ctx.stroke();
                this.ctx.setLineDash([]);
                
                // Point
                this.ctx.fillStyle = '#ff6b6b';
                this.ctx.strokeStyle = '#fff';
                this.ctx.lineWidth = 2;
                this.ctx.beginPath();
                this.ctx.arc(sx, sy, 8, 0, 2 * Math.PI);
                this.ctx.fill();
                this.ctx.stroke();
                
                // Draw auxiliary point if exists
                if (sampler.auxiliaryPoint) {
                    const az = this.gaussianPDF(sampler.auxiliaryPoint[0], sampler.auxiliaryPoint[1], sampler.covInv) * 5;
                    const [ax, ay] = this.project3D(sampler.auxiliaryPoint[0], sampler.auxiliaryPoint[1], az);
                    
                    this.ctx.fillStyle = '#4ecdc4';
                    this.ctx.strokeStyle = '#fff';
                    this.ctx.lineWidth = 2;
                    this.ctx.beginPath();
                    this.ctx.arc(ax, ay, 6, 0, 2 * Math.PI);
                    this.ctx.fill();
                    this.ctx.stroke();
                }
            }
        }
        
        class EllipticalSliceSampler2D {
            constructor(canvas) {
                this.canvas = canvas;
                this.ctx = canvas.getContext('2d');
                this.width = canvas.width;
                this.height = canvas.height;
                
                // Current state
                this.currentPoint = [0, 0];
                this.samples = [];
                this.auxiliaryPoint = null;
                this.currentTheta = 0;
                this.sliceMin = 0;
                this.sliceMax = 2 * Math.PI;
                this.ellipsePath = [];
                this.crossingPoints = [];
                
                // Parameters
                this.correlation = 0.6;
                this.sigmaX = 1.2;
                this.sigmaY = 0.8;
                this.likelihoodThreshold = -2;
                
                // Display options
                this.showContours = true;
                this.showCrossings = true;
                
                // Animation
                this.isRunning = false;
                this.animationSpeed = 30;
                
                // Statistics
                this.acceptCount = 0;
                this.totalSteps = 0;
                
                this.updateCovarianceMatrix();
            }
            
            updateCovarianceMatrix() {
                this.covMatrix = [
                    [this.sigmaX * this.sigmaX, this.correlation * this.sigmaX * this.sigmaY],
                    [this.correlation * this.sigmaX * this.sigmaY, this.sigmaY * this.sigmaY]
                ];
                
                const det = this.covMatrix[0][0] * this.covMatrix[1][1] - 
                           this.covMatrix[0][1] * this.covMatrix[1][0];
                this.covInv = [
                    [this.covMatrix[1][1] / det, -this.covMatrix[0][1] / det],
                    [-this.covMatrix[1][0] / det, this.covMatrix[0][0] / det]
                ];
            }
            
            sampleGaussian() {
                const u1 = Math.random();
                const u2 = Math.random();
                const z0 = Math.sqrt(-2 * Math.log(u1)) * Math.cos(2 * Math.PI * u2);
                const z1 = Math.sqrt(-2 * Math.log(u1)) * Math.sin(2 * Math.PI * u2);
                
                const L00 = Math.sqrt(this.covMatrix[0][0]);
                const L10 = this.covMatrix[1][0] / L00;
                const L11 = Math.sqrt(this.covMatrix[1][1] - L10 * L10);
                
                return [
                    L00 * z0,
                    L10 * z0 + L11 * z1
                ];
            }
            
            logLikelihood(point) {
                const [x, y] = point;
                const mahalanobis = x * x * this.covInv[0][0] + 
                                  2 * x * y * this.covInv[0][1] + 
                                  y * y * this.covInv[1][1];
                return -0.5 * mahalanobis;
            }
            
            getProbability(point) {
                const [x, y] = point;
                const mahalanobis = x * x * this.covInv[0][0] + 
                                  2 * x * y * this.covInv[0][1] + 
                                  y * y * this.covInv[1][1];
                return Math.exp(-0.5 * mahalanobis) / (2 * Math.PI);
            }
            
            step() {
                this.auxiliaryPoint = this.sampleGaussian();
                this.currentTheta = Math.random() * 2 * Math.PI;
                this.sliceMin = this.currentTheta - 2 * Math.PI;
                this.sliceMax = this.currentTheta;
                
                let attempts = 0;
                const maxAttempts = 100;
                
                while (attempts < maxAttempts) {
                    const cos_t = Math.cos(this.currentTheta);
                    const sin_t = Math.sin(this.currentTheta);
                    const proposedPoint = [
                        this.currentPoint[0] * cos_t + this.auxiliaryPoint[0] * sin_t,
                        this.currentPoint[1] * cos_t + this.auxiliaryPoint[1] * sin_t
                    ];
                    
                    if (this.logLikelihood(proposedPoint) > this.likelihoodThreshold) {
                        this.currentPoint = proposedPoint;
                        this.samples.push([...proposedPoint]);
                        if (this.samples.length > 200) {
                            this.samples.shift();
                        }
                        this.acceptCount++;
                        break;
                    } else {
                        if (this.currentTheta < 0) {
                            this.sliceMin = this.currentTheta;
                        } else {
                            this.sliceMax = this.currentTheta;
                        }
                        this.currentTheta = Math.random() * (this.sliceMax - this.sliceMin) + this.sliceMin;
                    }
                    attempts++;
                }
                
                this.totalSteps++;
                this.computeEllipsePath();
                this.findCrossingPoints();
            }
            
            computeEllipsePath() {
                this.ellipsePath = [];
                if (!this.auxiliaryPoint) return;
                
                for (let t = 0; t <= 2 * Math.PI; t += 0.02) {
                    const cos_t = Math.cos(t);
                    const sin_t = Math.sin(t);
                    this.ellipsePath.push([
                        this.currentPoint[0] * cos_t + this.auxiliaryPoint[0] * sin_t,
                        this.currentPoint[1] * cos_t + this.auxiliaryPoint[1] * sin_t
                    ]);
                }
            }
            
            findCrossingPoints() {
                this.crossingPoints = [];
                if (this.ellipsePath.length < 2) return;
                
                const contourLevels = [0.02, 0.05, 0.1, 0.15, 0.18];
                
                for (let i = 1; i < this.ellipsePath.length; i++) {
                    const p1 = this.getProbability(this.ellipsePath[i-1]);
                    const p2 = this.getProbability(this.ellipsePath[i]);
                    
                    for (const level of contourLevels) {
                        if ((p1 - level) * (p2 - level) < 0) {
                            // Crossing detected
                            const t = (level - p1) / (p2 - p1);
                            const crossPoint = [
                                this.ellipsePath[i-1][0] + t * (this.ellipsePath[i][0] - this.ellipsePath[i-1][0]),
                                this.ellipsePath[i-1][1] + t * (this.ellipsePath[i][1] - this.ellipsePath[i-1][1])
                            ];
                            this.crossingPoints.push({point: crossPoint, level: level});
                        }
                    }
                }
            }
            
            worldToCanvas(point) {
                const scale = 70;
                return [
                    this.width / 2 + point[0] * scale,
                    this.height / 2 - point[1] * scale
                ];
            }
            
            draw() {
                // Clear canvas with gradient background
                const gradient = this.ctx.createRadialGradient(
                    this.width/2, this.height/2, 0,
                    this.width/2, this.height/2, this.width/2
                );
                gradient.addColorStop(0, '#fafafa');
                gradient.addColorStop(1, '#f0f0f0');
                this.ctx.fillStyle = gradient;
                this.ctx.fillRect(0, 0, this.width, this.height);
                
                // Draw grid
                this.ctx.strokeStyle = '#e0e0e0';
                this.ctx.lineWidth = 0.5;
                for (let i = 0; i <= this.width; i += 30) {
                    this.ctx.beginPath();
                    this.ctx.moveTo(i, 0);
                    this.ctx.lineTo(i, this.height);
                    this.ctx.stroke();
                }
                for (let i = 0; i <= this.height; i += 30) {
                    this.ctx.beginPath();
                    this.ctx.moveTo(0, i);
                    this.ctx.lineTo(this.width, i);
                    this.ctx.stroke();
                }
                
                // Draw axes
                this.ctx.strokeStyle = '#999';
                this.ctx.lineWidth = 1.5;
                this.ctx.beginPath();
                this.ctx.moveTo(0, this.height / 2);
                this.ctx.lineTo(this.width, this.height / 2);
                this.ctx.moveTo(this.width / 2, 0);
                this.ctx.lineTo(this.width / 2, this.height);
                this.ctx.stroke();
                
                // Draw filled contour regions
                if (this.showContours) {
                    const contourLevels = [0.18, 0.15, 0.1, 0.05, 0.02];
                    for (const level of contourLevels) {
                        this.ctx.fillStyle = getHeightColor(level * 5);
                        this.ctx.globalAlpha = 0.1;
                        this.ctx.beginPath();
                        
                        const r = Math.sqrt(-2 * Math.log(level * 2 * Math.PI));
                        for (let angle = 0; angle <= 2 * Math.PI; angle += 0.05) {
                            const x = r * Math.cos(angle) * this.sigmaX;
                            const y = r * Math.sin(angle) * this.sigmaY;
                            
                            const tx = x;
                            const ty = this.correlation * x + Math.sqrt(Math.max(0, 1 - this.correlation * this.correlation)) * y;
                            
                            const [cx, cy] = this.worldToCanvas([tx, ty]);
                            if (angle === 0) {
                                this.ctx.moveTo(cx, cy);
                            } else {
                                this.ctx.lineTo(cx, cy);
                            }
                        }
                        this.ctx.closePath();
                        this.ctx.fill();
                        this.ctx.globalAlpha = 1;
                        
                        // Draw contour line
                        this.ctx.strokeStyle = getHeightColor(level * 5);
                        this.ctx.lineWidth = 1.5;
                        this.ctx.globalAlpha = 0.6;
                        this.ctx.stroke();
                        this.ctx.globalAlpha = 1;
                    }
                }
                
                // Draw samples
                for (let i = 0; i < this.samples.length; i++) {
                    const alpha = 0.1 + (i / this.samples.length) * 0.3;
                    const p = this.getProbability(this.samples[i]);
                    this.ctx.fillStyle = `rgba(78, 205, 196, ${alpha})`;
                    const [cx, cy] = this.worldToCanvas(this.samples[i]);
                    this.ctx.beginPath();
                    this.ctx.arc(cx, cy, 2 + p * 20, 0, 2 * Math.PI);
                    this.ctx.fill();
                }
                
                // Draw ellipse path
                if (this.ellipsePath.length > 0) {
                    // Draw full ellipse
                    this.ctx.strokeStyle = '#ffd93d';
                    this.ctx.lineWidth = 3;
                    this.ctx.globalAlpha = 0.7;
                    this.ctx.setLineDash([8, 4]);
                    this.ctx.beginPath();
                    for (let i = 0; i < this.ellipsePath.length; i++) {
                        const [cx, cy] = this.worldToCanvas(this.ellipsePath[i]);
                        if (i === 0) {
                            this.ctx.moveTo(cx, cy);
                        } else {
                            this.ctx.lineTo(cx, cy);
                        }
                    }
                    this.ctx.closePath();
                    this.ctx.stroke();
                    this.ctx.setLineDash([]);
                    this.ctx.globalAlpha = 1;
                    
                    // Draw crossing points
                    if (this.showCrossings) {
                        for (const crossing of this.crossingPoints) {
                            const [cx, cy] = this.worldToCanvas(crossing.point);
                            this.ctx.fillStyle = getHeightColor(crossing.level * 5);
                            this.ctx.strokeStyle = '#fff';
                            this.ctx.lineWidth = 2;
                            this.ctx.beginPath();
                            this.ctx.arc(cx, cy, 5, 0, 2 * Math.PI);
                            this.ctx.fill();
                            this.ctx.stroke();
                        }
                    }
                    
                    // Draw valid slice
                    if (this.sliceMax - this.sliceMin < 2 * Math.PI) {
                        this.ctx.strokeStyle = '#95e77e';
                        this.ctx.lineWidth = 5;
                        this.ctx.globalAlpha = 0.8;
                        this.ctx.shadowBlur = 10;
                        this.ctx.shadowColor = '#95e77e';
                        this.ctx.beginPath();
                        for (let t = this.sliceMin; t <= this.sliceMax; t += 0.02) {
                            const cos_t = Math.cos(t);
                            const sin_t = Math.sin(t);
                            const point = [
                                this.currentPoint[0] * cos_t + this.auxiliaryPoint[0] * sin_t,
                                this.currentPoint[1] * cos_t + this.auxiliaryPoint[1] * sin_t
                            ];
                            const [cx, cy] = this.worldToCanvas(point);
                            if (t === this.sliceMin) {
                                this.ctx.moveTo(cx, cy);
                            } else {
                                this.ctx.lineTo(cx, cy);
                            }
                        }
                        this.ctx.stroke();
                        this.ctx.shadowBlur = 0;
                        this.ctx.globalAlpha = 1;
                    }
                }
                
                // Draw auxiliary point
                if (this.auxiliaryPoint) {
                    const [cx, cy] = this.worldToCanvas(this.auxiliaryPoint);
                    this.ctx.fillStyle = '#4ecdc4';
                    this.ctx.strokeStyle = '#fff';
                    this.ctx.lineWidth = 2;
                    this.ctx.beginPath();
                    this.ctx.arc(cx, cy, 7, 0, 2 * Math.PI);
                    this.ctx.fill();
                    this.ctx.stroke();
                    
                    // Label
                    this.ctx.fillStyle = '#333';
                    this.ctx.font = 'bold 14px Arial';
                    this.ctx.fillText('ŒΩ', cx + 12, cy - 12);
                }
                
                // Draw current point
                const [cx, cy] = this.worldToCanvas(this.currentPoint);
                const currentP = this.getProbability(this.currentPoint);
                
                // Draw shadow/glow based on probability
                this.ctx.fillStyle = getHeightColor(currentP * 5);
                this.ctx.globalAlpha = 0.3;
                this.ctx.beginPath();
                this.ctx.arc(cx, cy, 20, 0, 2 * Math.PI);
                this.ctx.fill();
                this.ctx.globalAlpha = 1;
                
                this.ctx.fillStyle = '#ff6b6b';
                this.ctx.strokeStyle = '#fff';
                this.ctx.lineWidth = 3;
                this.ctx.beginPath();
                this.ctx.arc(cx, cy, 9, 0, 2 * Math.PI);
                this.ctx.fill();
                this.ctx.stroke();
                
                // Draw proposed point
                if (this.auxiliaryPoint && this.currentTheta !== undefined) {
                    const cos_t = Math.cos(this.currentTheta);
                    const sin_t = Math.sin(this.currentTheta);
                    const proposedPoint = [
                        this.currentPoint[0] * cos_t + this.auxiliaryPoint[0] * sin_t,
                        this.currentPoint[1] * cos_t + this.auxiliaryPoint[1] * sin_t
                    ];
                    const [px, py] = this.worldToCanvas(proposedPoint);
                    
                    // Connection line
                    this.ctx.strokeStyle = 'rgba(255, 107, 107, 0.4)';
                    this.ctx.lineWidth = 2;
                    this.ctx.setLineDash([4, 4]);
                    this.ctx.beginPath();
                    this.ctx.moveTo(cx, cy);
                    this.ctx.lineTo(px, py);
                    this.ctx.stroke();
                    this.ctx.setLineDash([]);
                    
                    // Proposed point
                    this.ctx.fillStyle = '#ff9ff3';
                    this.ctx.strokeStyle = '#fff';
                    this.ctx.lineWidth = 2;
                    this.ctx.beginPath();
                    this.ctx.arc(px, py, 6, 0, 2 * Math.PI);
                    this.ctx.fill();
                    this.ctx.stroke();
                }
            }
            
            reset() {
                this.currentPoint = [0, 0];
                this.samples = [];
                this.auxiliaryPoint = null;
                this.currentTheta = 0;
                this.sliceMin = 0;
                this.sliceMax = 2 * Math.PI;
                this.ellipsePath = [];
                this.crossingPoints = [];
                this.acceptCount = 0;
                this.totalSteps = 0;
            }
            
            updateStats() {
                const acceptRate = this.totalSteps > 0 ? 
                    (this.acceptCount / this.totalSteps * 100).toFixed(1) : 0;
                const currentP = this.getProbability(this.currentPoint);
                
                document.getElementById('stats').innerHTML = `
                    Samples: ${this.samples.length}<br>
                    Accept Rate: ${acceptRate}%<br>
                    Current Œ∏: ${this.currentTheta.toFixed(2)}<br>
                    Current P: ${currentP.toFixed(3)}<br>
                    Crossings: ${this.crossingPoints.length}
                `;
            }
        }
        
        // Initialize both visualizations
        const canvas3d = document.getElementById('canvas3d');
        const canvas2d = document.getElementById('canvas2d');
        const visualizer3D = new GaussianVisualizer3D(canvas3d);
        const sampler = new EllipticalSliceSampler2D(canvas2d);
        
        // Animation loop for 3D visualization
        function animate3D() {
            visualizer3D.draw(sampler);
            requestAnimationFrame(animate3D);
        }
        animate3D();
        
        // Controls
        document.getElementById('stepBtn').addEventListener('click', () => {
            sampler.step();
            sampler.draw();
            sampler.updateStats();
        });
        
        document.getElementById('runBtn').addEventListener('click', function() {
            sampler.isRunning = !sampler.isRunning;
            this.textContent = sampler.isRunning ? 'Stop' : 'Run';
            
            if (sampler.isRunning) {
                const animate = () => {
                    if (sampler.isRunning) {
                        sampler.step();
                        sampler.draw();
                        sampler.updateStats();
                        setTimeout(animate, 1000 / (sampler.animationSpeed / 10));
                    }
                };
                animate();
            }
        });
        
        document.getElementById('resetBtn').addEventListener('click', () => {
            sampler.reset();
            sampler.draw();
            sampler.updateStats();
        });
        
        document.getElementById('clearBtn').addEventListener('click', () => {
            sampler.samples = [];
            sampler.crossingPoints = [];
            sampler.draw();
            sampler.updateStats();
        });
        
        // Display options
        document.getElementById('showMesh').addEventListener('change', function() {
            visualizer3D.showMesh = this.checked;
        });
        
        document.getElementById('showContours').addEventListener('change', function() {
            visualizer3D.showContours = this.checked;
            sampler.showContours = this.checked;
            sampler.draw();
        });
        
        document.getElementById('showCrossings').addEventListener('change', function() {
            visualizer3D.showCrossings = this.checked;
            sampler.showCrossings = this.checked;
            sampler.draw();
        });
        
        document.getElementById('rotate3D').addEventListener('change', function() {
            visualizer3D.autoRotate = this.checked;
        });
        
        // Parameter controls
        document.getElementById('likelihood').addEventListener('input', function() {
            sampler.likelihoodThreshold = parseFloat(this.value);
            document.getElementById('likelihoodValue').textContent = this.value;
            sampler.draw();
        });
        
        document.getElementById('speed').addEventListener('input', function() {
            sampler.animationSpeed = parseInt(this.value);
            document.getElementById('speedValue').textContent = this.value;
        });
        
        document.getElementById('correlation').addEventListener('input', function() {
            sampler.correlation = parseFloat(this.value);
            document.getElementById('correlationValue').textContent = this.value;
            sampler.updateCovarianceMatrix();
            sampler.draw();
        });
        
        document.getElementById('sigmaX').addEventListener('input', function() {
            sampler.sigmaX = parseFloat(this.value);
            document.getElementById('sigmaXValue').textContent = this.value;
            sampler.updateCovarianceMatrix();
            sampler.draw();
        });
        
        document.getElementById('sigmaY').addEventListener('input', function() {
            sampler.sigmaY = parseFloat(this.value);
            document.getElementById('sigmaYValue').textContent = this.value;
            sampler.updateCovarianceMatrix();
            sampler.draw();
        });
        
        // Initial draw
        sampler.draw();
        sampler.updateStats();
    </script>
</body>
</html>